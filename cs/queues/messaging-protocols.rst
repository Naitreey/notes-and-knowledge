AMQP
====
overview
--------
- Advanced Message Queuing Protocol.

- design principle: interoperability between different vendors. Conforming
  client applications can communicate with conforming message broker
  middlewares.

- features:
  
  * reliability
   
  * interoperability

  * feature rich

  * a binary wire protocol

  * programmable. AMQP entities and routing schemes are primarily defined by
    applications themselves, not a broker administrator.

- It assumes an underlying reliable transport layer protocol such as TCP.

- AMQP was originally designed by JP Morgan.

terms
-----
AMQP entities: exchanges, queues, bindings are collectively called AMQP
entities.

operation model
---------------
- Overview: Message broker receives messages from producers, and route them to
  consumers.

- In detail:

  * Messages are published to exchanges. Exchanges distribute message copies to
    queues using binding rules.

  * When a message cannot be routed, messages may be:
 
    * returned to producer

    * dropped

    * placed into a dead letter queue.

  * Message broker push messages to consumers or consumers pull messages on
    demand. Messages are distributed between multiple consumers in a round
    robin manner.

    Note that messages are load balanced between consumers and not between
    queues.

exchange
--------
- Messages are sent to exchange. Exchanges take a message and route it into
  zero or more queues.

- Routing algorithm is determined by exchange type and binding rules.

- exchange attributes:

  * name
  
  * type
  
  * durability (whether survive restart -- durable or transient)
  
  * auto-delete (auto-delete when last queue is unbound)
  
  * arguments (optional, broker-specific)

- An exchange needs to be declared before use. Re-declaring an existing exchange
  with the same attributes has no effect, otherwise a channel-level exception
  with code 406 (PRECONDITION_FAILED) will be raised.

direct exchange
^^^^^^^^^^^^^^^
- 机制: With a queue binds to the exchange with a routing key K, when a new
  message with routing key R arrives at the direct exchange, the exchange
  routes it to the queue if K = R.

- direct exchange is good for:

  * message unicasting

  * message multicasting

- predefined: "" (default exchange), amq.direct

- "" default exchange:

  * every queue that is created is automatically bound to default exchange with
    a routing key which is the same as the queue name.

  * the default exchange makes it seem like it is possible to deliver messages
    directly to queues, even though that is not technically what is happening.

fanout exchange
^^^^^^^^^^^^^^^
- 机制: A fanout exchange routes messages to all of the queues that are bound
  to it and the routing key is ignored.

- good for:

  * message broadcasting

- predefined: amq.fanout

topic exchange
^^^^^^^^^^^^^^
- 机制: route messages to one or many queues based on matching between a
  message routing key and the pattern that was used to bind a queue to an
  exchange.

- good for:

  * message multicasting

  * publish/subscribe

- predefined: amq.topic

headers exchange
^^^^^^^^^^^^^^^^
- 机制: routing on multiple attributes that are more easily expressed as
  message headers than a routing key. Headers exchanges ignore the routing key
  attribute.
  
  * A message is considered matching if the values of the header equals the
    values specified upon binding.

  * When binding with multiple headers, ``x-match`` binding argument specify
    operator to combine the matching result of each header. ``any`` or ``all``.

- they can be used as direct exchanges where the routing key does not have to
  be a string (e.g., integer or hash table).

- predefined: amq.match, amq.headers

queue
-----
- A queue keeps messages to be consumed by consumers.

- queue attributes:

  * name

  * durability

  * exclusive (exclusive to one connection, auto-deleted when connection is
    closed)

  * auto-delete (auto-delete queue when last consumer unsubscribe)

  * arguments (optional, broker-specific)

- A queue needs to be declared before use. Re-declaring an existing queue with
  the same attributes has no effect, otherwise a channel-level exception with
  code 406 (PRECONDITION_FAILED) will be raised.

name
^^^^
- Name can be defined by client or generated by broker automatically. To let
  broker generate a name, pass an empty string as the queue name.

- Name max 255 bytes.

- Name encoding UTF-8

- Queue names starting with "amq." are reserved for internal use by the broker.
  Attempts to declare a queue starting with "amq." will result in a
  channel-level exception with reply code 403 (ACCESS_REFUSED).

durability
^^^^^^^^^^
- If broker is taken down and then brought back up, durable queue will be
  re-declared during broker startup. 这也意味着 message 不会自动 durable.

bindings
--------
- Bindings are rules that exchanges use (among other things) to route messages
  to queues. A queue has to bound an exchange to be useful. Bindings may have
  an optional routing key attribute used by some exchange types.

consumer
--------

message consuming
^^^^^^^^^^^^^^^^^
- Two ways for consumer to consume messages:

  * broker push message to consumer (push API)

  * consumer fetch message from broker (pull API)

- push API:
  
  * consumer subscribe to a queue, indicating they wanna receive messages.

  * Each subscription has a consumer tag. Provide this consumer tag to
    unsubscribe from a queue.

message acknowledgement
^^^^^^^^^^^^^^^^^^^^^^^
AMQP specification propose two choices for when a broker can remove messages
from queues:

- automatic acknowledgement model

- explicit acknowledgement model

automatic acknowledgement model
"""""""""""""""""""""""""""""""
- Broker remove message after sending it to an application (using either
  basic.deliver or basic.get-ok AMQP methods).

explicit acknowledgement model
""""""""""""""""""""""""""""""
- Broker remove message after the application sends back an acknowledgement
  (using basic.ack AMQP method). Message ack 的机制与 TCP ack 的机制是相似的.

  当 consumer 收到消息后, choose a time to notify broker about the fact. It can
  be any time, 取决于应用认为何时算是消息处理已经结束.

  If a consumer dies without sending an acknowledgement the AMQP broker will
  redeliver it to another consumer.

- explicit message acknowledgement 的原因: 用于解决 reliable message delivery.
  这里的可靠性指的不是消息传输的可靠性 (这由 TCP 保证), 而是 consumer 应用对消
  息处理的可靠性.

  一条消息的 successful delivery, 表示 consumer 认可并能够"消化"该消息. 若
  consumer 拒绝或消化不了这条消息, 则不认为 delivery 是成功的.
  
  因此, 需要一个应用层的 ack 机制, 来表示应用层的 delivery (而非仅仅 TCP 层).

Rejecting messages
^^^^^^^^^^^^^^^^^^
- An application can indicate to the broker that message processing has failed
  (or cannot be accomplished at the time) by rejecting a message.

- Consumer can ask broker to discard or requeue the message when rejecting a
  message.

Negative acknowledgement
^^^^^^^^^^^^^^^^^^^^^^^^
- an AMQP 0-9-1 extension, also known as nacks.

- Can be used to reject multiple messages.

Message Prefetching
^^^^^^^^^^^^^^^^^^^
- Specify how many messages each consumer can be sent at once before sending
  the next acknowledgement.

- useful for

  * load balancing

  * improve throughput (if set to higher value)

message
-------

attributes
^^^^^^^^^^
- Message attributes/properties are a message's metadata.

  * Content type. message encoding as mime-type.
  
  * Content encoding.
  
  * Routing key.
  
  * Delivery mode. transitent message (1), persistent message (2).
  
  * Message priority.
  
  * Message publishing timestamp.
  
  * Expiration period.
  
  * Publisher application id.
  
  * ``reply_to``. the name of a callback queue.
  
  * ``correlation_id``. Useful to correlate RPC responses with requests.

- Message attributes are set when a message is published.

message persistence
^^^^^^^^^^^^^^^^^^^
- depends on persistence mode of the message itself.

- Persistent messages are persisted to disk. Publishing messages as persistent
  affects performance. 然而 durable exchange/queue 并没有 performance 问题, 因为
  只是在重启后再次声明和绑定而已.

payload
^^^^^^^
- the data that a message carries.

- AMQP brokers treat payload as an opaque byte array.

- AMQP peers typically use the "content-type" and "content-encoding" fields to
  indicate how to deserialize the payload.

methods
-------
- AMQP methods are just operations, and have nothing in common with OOP method.

- AMQP methods are grouped into classes.

basic class
^^^^^^^^^^^
- basic.ack

- basic.cancel (basic.cancel-ok)

- basic.consume (basic.consume-ok)

- basic.deliver

- basic.get (basic.get-ok, basic.get-empty)

- basic.nack

- basic.publish

- basic.qos (basic.qos-ok)

- basic.recover

- basic.recover-async

- basic.reject

- basic.return

channel class
^^^^^^^^^^^^^
- channel.open (channel.open-ok)

- channel.close (channel.close-ok)

- channel.flow (channel.flow-ok)

confirm class
^^^^^^^^^^^^^
- confirm.select (confirm.select-ok)

exchange class
^^^^^^^^^^^^^^
- exchange.declare (exchange.declare-ok)

- exchange.delete (exchange.delete-ok)

- exchange.bind (exchange.bind-ok)

- exchange.unbind (exchange.unbind-ok)

queue class
^^^^^^^^^^^
- queue.declare (queue.declare-ok)

- queue.delete (queue.delete-ok)

- queue.bind (queue.bind-ok)

- queue.unbind (queue.unbind-ok)

- queue.purge (queue.purge-ok)

tx class
^^^^^^^^
- tx.commit (tx.commit-ok)

- tx.rollback (tx.rollback-ok)

- tx.select (tx.select-ok)

connection
----------
- AMQP uses TCP for reliable delivery.

- AMQP connection is typically long-lived.

Channel
-------
- designed to be able to maintain multiple sessions at the same time, without
  opening multiple TCP connections. 因为多开 TCP 连接会带来系统资源消耗, 更复杂
  的 firewall configuration, etc.

- AMQP 0-9-1 connections are multiplexed with channels that can be thought of
  as "lightweight connections that share a single TCP connection".

- Communication on a particular channel is completely separate from
  communication on another channel, therefore every AMQP method also carries a
  channel number that clients use to figure out which channel the method is
  for.

Virtual host
------------
- vhost: for a single broker to host multiple isolated environments.

- 在不同 vhost 中的 AMQP entities 是完全独立的.

- AMQP clients specify what vhosts they want to use during AMQP connection
  negotiation.

extensibility
-------------
- custom exchange types

- additional exchange, queue, message attributes

implementations
---------------

* Apache Qpid

* Apache ActiveMQ

* RabbitMQ

major versions
--------------

* 1.0

* 0-9-1

MQTT
====
- Message Queue Telemetry Transport

- design principle: suitable for resource-constrained devices and low
  bandwidth, high latency networks.

- features:

  * suitable for IoT, embedded devices

  * simplicity

  * a compact binary packet payload

- publish-and-subscribe messaging, no queues

STOMP
=====
- Simple/Streaming Text Oriented Messaging Protocol

- design principle: simple, and widely-interoperable.

- features:

  * text-based

  * simplicity

  * interoperability

- no queues and topics, it uses a SEND semantic with a “destination” string.
